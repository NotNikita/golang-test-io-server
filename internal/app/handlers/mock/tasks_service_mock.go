// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i test-server/internal/app/handlers.TasksService -o tasks_service_mock.go -n TasksServiceMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"test-server/internal/domain/model"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// TasksServiceMock implements mm_handlers.TasksService
type TasksServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDeleteTask          func(ctx context.Context, taskId string) (err error)
	funcDeleteTaskOrigin    string
	inspectFuncDeleteTask   func(ctx context.Context, taskId string)
	afterDeleteTaskCounter  uint64
	beforeDeleteTaskCounter uint64
	DeleteTaskMock          mTasksServiceMockDeleteTask

	funcRegisterTask          func(ctx context.Context, title string) (s1 string, err error)
	funcRegisterTaskOrigin    string
	inspectFuncRegisterTask   func(ctx context.Context, title string)
	afterRegisterTaskCounter  uint64
	beforeRegisterTaskCounter uint64
	RegisterTaskMock          mTasksServiceMockRegisterTask

	funcTaskInfo          func(ctx context.Context, taskId string) (tp1 *model.Task, err error)
	funcTaskInfoOrigin    string
	inspectFuncTaskInfo   func(ctx context.Context, taskId string)
	afterTaskInfoCounter  uint64
	beforeTaskInfoCounter uint64
	TaskInfoMock          mTasksServiceMockTaskInfo
}

// NewTasksServiceMock returns a mock for mm_handlers.TasksService
func NewTasksServiceMock(t minimock.Tester) *TasksServiceMock {
	m := &TasksServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteTaskMock = mTasksServiceMockDeleteTask{mock: m}
	m.DeleteTaskMock.callArgs = []*TasksServiceMockDeleteTaskParams{}

	m.RegisterTaskMock = mTasksServiceMockRegisterTask{mock: m}
	m.RegisterTaskMock.callArgs = []*TasksServiceMockRegisterTaskParams{}

	m.TaskInfoMock = mTasksServiceMockTaskInfo{mock: m}
	m.TaskInfoMock.callArgs = []*TasksServiceMockTaskInfoParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTasksServiceMockDeleteTask struct {
	optional           bool
	mock               *TasksServiceMock
	defaultExpectation *TasksServiceMockDeleteTaskExpectation
	expectations       []*TasksServiceMockDeleteTaskExpectation

	callArgs []*TasksServiceMockDeleteTaskParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TasksServiceMockDeleteTaskExpectation specifies expectation struct of the TasksService.DeleteTask
type TasksServiceMockDeleteTaskExpectation struct {
	mock               *TasksServiceMock
	params             *TasksServiceMockDeleteTaskParams
	paramPtrs          *TasksServiceMockDeleteTaskParamPtrs
	expectationOrigins TasksServiceMockDeleteTaskExpectationOrigins
	results            *TasksServiceMockDeleteTaskResults
	returnOrigin       string
	Counter            uint64
}

// TasksServiceMockDeleteTaskParams contains parameters of the TasksService.DeleteTask
type TasksServiceMockDeleteTaskParams struct {
	ctx    context.Context
	taskId string
}

// TasksServiceMockDeleteTaskParamPtrs contains pointers to parameters of the TasksService.DeleteTask
type TasksServiceMockDeleteTaskParamPtrs struct {
	ctx    *context.Context
	taskId *string
}

// TasksServiceMockDeleteTaskResults contains results of the TasksService.DeleteTask
type TasksServiceMockDeleteTaskResults struct {
	err error
}

// TasksServiceMockDeleteTaskOrigins contains origins of expectations of the TasksService.DeleteTask
type TasksServiceMockDeleteTaskExpectationOrigins struct {
	origin       string
	originCtx    string
	originTaskId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteTask *mTasksServiceMockDeleteTask) Optional() *mTasksServiceMockDeleteTask {
	mmDeleteTask.optional = true
	return mmDeleteTask
}

// Expect sets up expected params for TasksService.DeleteTask
func (mmDeleteTask *mTasksServiceMockDeleteTask) Expect(ctx context.Context, taskId string) *mTasksServiceMockDeleteTask {
	if mmDeleteTask.mock.funcDeleteTask != nil {
		mmDeleteTask.mock.t.Fatalf("TasksServiceMock.DeleteTask mock is already set by Set")
	}

	if mmDeleteTask.defaultExpectation == nil {
		mmDeleteTask.defaultExpectation = &TasksServiceMockDeleteTaskExpectation{}
	}

	if mmDeleteTask.defaultExpectation.paramPtrs != nil {
		mmDeleteTask.mock.t.Fatalf("TasksServiceMock.DeleteTask mock is already set by ExpectParams functions")
	}

	mmDeleteTask.defaultExpectation.params = &TasksServiceMockDeleteTaskParams{ctx, taskId}
	mmDeleteTask.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteTask.expectations {
		if minimock.Equal(e.params, mmDeleteTask.defaultExpectation.params) {
			mmDeleteTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteTask.defaultExpectation.params)
		}
	}

	return mmDeleteTask
}

// ExpectCtxParam1 sets up expected param ctx for TasksService.DeleteTask
func (mmDeleteTask *mTasksServiceMockDeleteTask) ExpectCtxParam1(ctx context.Context) *mTasksServiceMockDeleteTask {
	if mmDeleteTask.mock.funcDeleteTask != nil {
		mmDeleteTask.mock.t.Fatalf("TasksServiceMock.DeleteTask mock is already set by Set")
	}

	if mmDeleteTask.defaultExpectation == nil {
		mmDeleteTask.defaultExpectation = &TasksServiceMockDeleteTaskExpectation{}
	}

	if mmDeleteTask.defaultExpectation.params != nil {
		mmDeleteTask.mock.t.Fatalf("TasksServiceMock.DeleteTask mock is already set by Expect")
	}

	if mmDeleteTask.defaultExpectation.paramPtrs == nil {
		mmDeleteTask.defaultExpectation.paramPtrs = &TasksServiceMockDeleteTaskParamPtrs{}
	}
	mmDeleteTask.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteTask.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteTask
}

// ExpectTaskIdParam2 sets up expected param taskId for TasksService.DeleteTask
func (mmDeleteTask *mTasksServiceMockDeleteTask) ExpectTaskIdParam2(taskId string) *mTasksServiceMockDeleteTask {
	if mmDeleteTask.mock.funcDeleteTask != nil {
		mmDeleteTask.mock.t.Fatalf("TasksServiceMock.DeleteTask mock is already set by Set")
	}

	if mmDeleteTask.defaultExpectation == nil {
		mmDeleteTask.defaultExpectation = &TasksServiceMockDeleteTaskExpectation{}
	}

	if mmDeleteTask.defaultExpectation.params != nil {
		mmDeleteTask.mock.t.Fatalf("TasksServiceMock.DeleteTask mock is already set by Expect")
	}

	if mmDeleteTask.defaultExpectation.paramPtrs == nil {
		mmDeleteTask.defaultExpectation.paramPtrs = &TasksServiceMockDeleteTaskParamPtrs{}
	}
	mmDeleteTask.defaultExpectation.paramPtrs.taskId = &taskId
	mmDeleteTask.defaultExpectation.expectationOrigins.originTaskId = minimock.CallerInfo(1)

	return mmDeleteTask
}

// Inspect accepts an inspector function that has same arguments as the TasksService.DeleteTask
func (mmDeleteTask *mTasksServiceMockDeleteTask) Inspect(f func(ctx context.Context, taskId string)) *mTasksServiceMockDeleteTask {
	if mmDeleteTask.mock.inspectFuncDeleteTask != nil {
		mmDeleteTask.mock.t.Fatalf("Inspect function is already set for TasksServiceMock.DeleteTask")
	}

	mmDeleteTask.mock.inspectFuncDeleteTask = f

	return mmDeleteTask
}

// Return sets up results that will be returned by TasksService.DeleteTask
func (mmDeleteTask *mTasksServiceMockDeleteTask) Return(err error) *TasksServiceMock {
	if mmDeleteTask.mock.funcDeleteTask != nil {
		mmDeleteTask.mock.t.Fatalf("TasksServiceMock.DeleteTask mock is already set by Set")
	}

	if mmDeleteTask.defaultExpectation == nil {
		mmDeleteTask.defaultExpectation = &TasksServiceMockDeleteTaskExpectation{mock: mmDeleteTask.mock}
	}
	mmDeleteTask.defaultExpectation.results = &TasksServiceMockDeleteTaskResults{err}
	mmDeleteTask.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteTask.mock
}

// Set uses given function f to mock the TasksService.DeleteTask method
func (mmDeleteTask *mTasksServiceMockDeleteTask) Set(f func(ctx context.Context, taskId string) (err error)) *TasksServiceMock {
	if mmDeleteTask.defaultExpectation != nil {
		mmDeleteTask.mock.t.Fatalf("Default expectation is already set for the TasksService.DeleteTask method")
	}

	if len(mmDeleteTask.expectations) > 0 {
		mmDeleteTask.mock.t.Fatalf("Some expectations are already set for the TasksService.DeleteTask method")
	}

	mmDeleteTask.mock.funcDeleteTask = f
	mmDeleteTask.mock.funcDeleteTaskOrigin = minimock.CallerInfo(1)
	return mmDeleteTask.mock
}

// When sets expectation for the TasksService.DeleteTask which will trigger the result defined by the following
// Then helper
func (mmDeleteTask *mTasksServiceMockDeleteTask) When(ctx context.Context, taskId string) *TasksServiceMockDeleteTaskExpectation {
	if mmDeleteTask.mock.funcDeleteTask != nil {
		mmDeleteTask.mock.t.Fatalf("TasksServiceMock.DeleteTask mock is already set by Set")
	}

	expectation := &TasksServiceMockDeleteTaskExpectation{
		mock:               mmDeleteTask.mock,
		params:             &TasksServiceMockDeleteTaskParams{ctx, taskId},
		expectationOrigins: TasksServiceMockDeleteTaskExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteTask.expectations = append(mmDeleteTask.expectations, expectation)
	return expectation
}

// Then sets up TasksService.DeleteTask return parameters for the expectation previously defined by the When method
func (e *TasksServiceMockDeleteTaskExpectation) Then(err error) *TasksServiceMock {
	e.results = &TasksServiceMockDeleteTaskResults{err}
	return e.mock
}

// Times sets number of times TasksService.DeleteTask should be invoked
func (mmDeleteTask *mTasksServiceMockDeleteTask) Times(n uint64) *mTasksServiceMockDeleteTask {
	if n == 0 {
		mmDeleteTask.mock.t.Fatalf("Times of TasksServiceMock.DeleteTask mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteTask.expectedInvocations, n)
	mmDeleteTask.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteTask
}

func (mmDeleteTask *mTasksServiceMockDeleteTask) invocationsDone() bool {
	if len(mmDeleteTask.expectations) == 0 && mmDeleteTask.defaultExpectation == nil && mmDeleteTask.mock.funcDeleteTask == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteTask.mock.afterDeleteTaskCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteTask.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteTask implements mm_handlers.TasksService
func (mmDeleteTask *TasksServiceMock) DeleteTask(ctx context.Context, taskId string) (err error) {
	mm_atomic.AddUint64(&mmDeleteTask.beforeDeleteTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteTask.afterDeleteTaskCounter, 1)

	mmDeleteTask.t.Helper()

	if mmDeleteTask.inspectFuncDeleteTask != nil {
		mmDeleteTask.inspectFuncDeleteTask(ctx, taskId)
	}

	mm_params := TasksServiceMockDeleteTaskParams{ctx, taskId}

	// Record call args
	mmDeleteTask.DeleteTaskMock.mutex.Lock()
	mmDeleteTask.DeleteTaskMock.callArgs = append(mmDeleteTask.DeleteTaskMock.callArgs, &mm_params)
	mmDeleteTask.DeleteTaskMock.mutex.Unlock()

	for _, e := range mmDeleteTask.DeleteTaskMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteTask.DeleteTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteTask.DeleteTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteTask.DeleteTaskMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteTask.DeleteTaskMock.defaultExpectation.paramPtrs

		mm_got := TasksServiceMockDeleteTaskParams{ctx, taskId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteTask.t.Errorf("TasksServiceMock.DeleteTask got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTask.DeleteTaskMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.taskId != nil && !minimock.Equal(*mm_want_ptrs.taskId, mm_got.taskId) {
				mmDeleteTask.t.Errorf("TasksServiceMock.DeleteTask got unexpected parameter taskId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTask.DeleteTaskMock.defaultExpectation.expectationOrigins.originTaskId, *mm_want_ptrs.taskId, mm_got.taskId, minimock.Diff(*mm_want_ptrs.taskId, mm_got.taskId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteTask.t.Errorf("TasksServiceMock.DeleteTask got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteTask.DeleteTaskMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteTask.DeleteTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteTask.t.Fatal("No results are set for the TasksServiceMock.DeleteTask")
		}
		return (*mm_results).err
	}
	if mmDeleteTask.funcDeleteTask != nil {
		return mmDeleteTask.funcDeleteTask(ctx, taskId)
	}
	mmDeleteTask.t.Fatalf("Unexpected call to TasksServiceMock.DeleteTask. %v %v", ctx, taskId)
	return
}

// DeleteTaskAfterCounter returns a count of finished TasksServiceMock.DeleteTask invocations
func (mmDeleteTask *TasksServiceMock) DeleteTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTask.afterDeleteTaskCounter)
}

// DeleteTaskBeforeCounter returns a count of TasksServiceMock.DeleteTask invocations
func (mmDeleteTask *TasksServiceMock) DeleteTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTask.beforeDeleteTaskCounter)
}

// Calls returns a list of arguments used in each call to TasksServiceMock.DeleteTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteTask *mTasksServiceMockDeleteTask) Calls() []*TasksServiceMockDeleteTaskParams {
	mmDeleteTask.mutex.RLock()

	argCopy := make([]*TasksServiceMockDeleteTaskParams, len(mmDeleteTask.callArgs))
	copy(argCopy, mmDeleteTask.callArgs)

	mmDeleteTask.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteTaskDone returns true if the count of the DeleteTask invocations corresponds
// the number of defined expectations
func (m *TasksServiceMock) MinimockDeleteTaskDone() bool {
	if m.DeleteTaskMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteTaskMock.invocationsDone()
}

// MinimockDeleteTaskInspect logs each unmet expectation
func (m *TasksServiceMock) MinimockDeleteTaskInspect() {
	for _, e := range m.DeleteTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TasksServiceMock.DeleteTask at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteTaskCounter := mm_atomic.LoadUint64(&m.afterDeleteTaskCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteTaskMock.defaultExpectation != nil && afterDeleteTaskCounter < 1 {
		if m.DeleteTaskMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TasksServiceMock.DeleteTask at\n%s", m.DeleteTaskMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TasksServiceMock.DeleteTask at\n%s with params: %#v", m.DeleteTaskMock.defaultExpectation.expectationOrigins.origin, *m.DeleteTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteTask != nil && afterDeleteTaskCounter < 1 {
		m.t.Errorf("Expected call to TasksServiceMock.DeleteTask at\n%s", m.funcDeleteTaskOrigin)
	}

	if !m.DeleteTaskMock.invocationsDone() && afterDeleteTaskCounter > 0 {
		m.t.Errorf("Expected %d calls to TasksServiceMock.DeleteTask at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteTaskMock.expectedInvocations), m.DeleteTaskMock.expectedInvocationsOrigin, afterDeleteTaskCounter)
	}
}

type mTasksServiceMockRegisterTask struct {
	optional           bool
	mock               *TasksServiceMock
	defaultExpectation *TasksServiceMockRegisterTaskExpectation
	expectations       []*TasksServiceMockRegisterTaskExpectation

	callArgs []*TasksServiceMockRegisterTaskParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TasksServiceMockRegisterTaskExpectation specifies expectation struct of the TasksService.RegisterTask
type TasksServiceMockRegisterTaskExpectation struct {
	mock               *TasksServiceMock
	params             *TasksServiceMockRegisterTaskParams
	paramPtrs          *TasksServiceMockRegisterTaskParamPtrs
	expectationOrigins TasksServiceMockRegisterTaskExpectationOrigins
	results            *TasksServiceMockRegisterTaskResults
	returnOrigin       string
	Counter            uint64
}

// TasksServiceMockRegisterTaskParams contains parameters of the TasksService.RegisterTask
type TasksServiceMockRegisterTaskParams struct {
	ctx   context.Context
	title string
}

// TasksServiceMockRegisterTaskParamPtrs contains pointers to parameters of the TasksService.RegisterTask
type TasksServiceMockRegisterTaskParamPtrs struct {
	ctx   *context.Context
	title *string
}

// TasksServiceMockRegisterTaskResults contains results of the TasksService.RegisterTask
type TasksServiceMockRegisterTaskResults struct {
	s1  string
	err error
}

// TasksServiceMockRegisterTaskOrigins contains origins of expectations of the TasksService.RegisterTask
type TasksServiceMockRegisterTaskExpectationOrigins struct {
	origin      string
	originCtx   string
	originTitle string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterTask *mTasksServiceMockRegisterTask) Optional() *mTasksServiceMockRegisterTask {
	mmRegisterTask.optional = true
	return mmRegisterTask
}

// Expect sets up expected params for TasksService.RegisterTask
func (mmRegisterTask *mTasksServiceMockRegisterTask) Expect(ctx context.Context, title string) *mTasksServiceMockRegisterTask {
	if mmRegisterTask.mock.funcRegisterTask != nil {
		mmRegisterTask.mock.t.Fatalf("TasksServiceMock.RegisterTask mock is already set by Set")
	}

	if mmRegisterTask.defaultExpectation == nil {
		mmRegisterTask.defaultExpectation = &TasksServiceMockRegisterTaskExpectation{}
	}

	if mmRegisterTask.defaultExpectation.paramPtrs != nil {
		mmRegisterTask.mock.t.Fatalf("TasksServiceMock.RegisterTask mock is already set by ExpectParams functions")
	}

	mmRegisterTask.defaultExpectation.params = &TasksServiceMockRegisterTaskParams{ctx, title}
	mmRegisterTask.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterTask.expectations {
		if minimock.Equal(e.params, mmRegisterTask.defaultExpectation.params) {
			mmRegisterTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterTask.defaultExpectation.params)
		}
	}

	return mmRegisterTask
}

// ExpectCtxParam1 sets up expected param ctx for TasksService.RegisterTask
func (mmRegisterTask *mTasksServiceMockRegisterTask) ExpectCtxParam1(ctx context.Context) *mTasksServiceMockRegisterTask {
	if mmRegisterTask.mock.funcRegisterTask != nil {
		mmRegisterTask.mock.t.Fatalf("TasksServiceMock.RegisterTask mock is already set by Set")
	}

	if mmRegisterTask.defaultExpectation == nil {
		mmRegisterTask.defaultExpectation = &TasksServiceMockRegisterTaskExpectation{}
	}

	if mmRegisterTask.defaultExpectation.params != nil {
		mmRegisterTask.mock.t.Fatalf("TasksServiceMock.RegisterTask mock is already set by Expect")
	}

	if mmRegisterTask.defaultExpectation.paramPtrs == nil {
		mmRegisterTask.defaultExpectation.paramPtrs = &TasksServiceMockRegisterTaskParamPtrs{}
	}
	mmRegisterTask.defaultExpectation.paramPtrs.ctx = &ctx
	mmRegisterTask.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRegisterTask
}

// ExpectTitleParam2 sets up expected param title for TasksService.RegisterTask
func (mmRegisterTask *mTasksServiceMockRegisterTask) ExpectTitleParam2(title string) *mTasksServiceMockRegisterTask {
	if mmRegisterTask.mock.funcRegisterTask != nil {
		mmRegisterTask.mock.t.Fatalf("TasksServiceMock.RegisterTask mock is already set by Set")
	}

	if mmRegisterTask.defaultExpectation == nil {
		mmRegisterTask.defaultExpectation = &TasksServiceMockRegisterTaskExpectation{}
	}

	if mmRegisterTask.defaultExpectation.params != nil {
		mmRegisterTask.mock.t.Fatalf("TasksServiceMock.RegisterTask mock is already set by Expect")
	}

	if mmRegisterTask.defaultExpectation.paramPtrs == nil {
		mmRegisterTask.defaultExpectation.paramPtrs = &TasksServiceMockRegisterTaskParamPtrs{}
	}
	mmRegisterTask.defaultExpectation.paramPtrs.title = &title
	mmRegisterTask.defaultExpectation.expectationOrigins.originTitle = minimock.CallerInfo(1)

	return mmRegisterTask
}

// Inspect accepts an inspector function that has same arguments as the TasksService.RegisterTask
func (mmRegisterTask *mTasksServiceMockRegisterTask) Inspect(f func(ctx context.Context, title string)) *mTasksServiceMockRegisterTask {
	if mmRegisterTask.mock.inspectFuncRegisterTask != nil {
		mmRegisterTask.mock.t.Fatalf("Inspect function is already set for TasksServiceMock.RegisterTask")
	}

	mmRegisterTask.mock.inspectFuncRegisterTask = f

	return mmRegisterTask
}

// Return sets up results that will be returned by TasksService.RegisterTask
func (mmRegisterTask *mTasksServiceMockRegisterTask) Return(s1 string, err error) *TasksServiceMock {
	if mmRegisterTask.mock.funcRegisterTask != nil {
		mmRegisterTask.mock.t.Fatalf("TasksServiceMock.RegisterTask mock is already set by Set")
	}

	if mmRegisterTask.defaultExpectation == nil {
		mmRegisterTask.defaultExpectation = &TasksServiceMockRegisterTaskExpectation{mock: mmRegisterTask.mock}
	}
	mmRegisterTask.defaultExpectation.results = &TasksServiceMockRegisterTaskResults{s1, err}
	mmRegisterTask.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterTask.mock
}

// Set uses given function f to mock the TasksService.RegisterTask method
func (mmRegisterTask *mTasksServiceMockRegisterTask) Set(f func(ctx context.Context, title string) (s1 string, err error)) *TasksServiceMock {
	if mmRegisterTask.defaultExpectation != nil {
		mmRegisterTask.mock.t.Fatalf("Default expectation is already set for the TasksService.RegisterTask method")
	}

	if len(mmRegisterTask.expectations) > 0 {
		mmRegisterTask.mock.t.Fatalf("Some expectations are already set for the TasksService.RegisterTask method")
	}

	mmRegisterTask.mock.funcRegisterTask = f
	mmRegisterTask.mock.funcRegisterTaskOrigin = minimock.CallerInfo(1)
	return mmRegisterTask.mock
}

// When sets expectation for the TasksService.RegisterTask which will trigger the result defined by the following
// Then helper
func (mmRegisterTask *mTasksServiceMockRegisterTask) When(ctx context.Context, title string) *TasksServiceMockRegisterTaskExpectation {
	if mmRegisterTask.mock.funcRegisterTask != nil {
		mmRegisterTask.mock.t.Fatalf("TasksServiceMock.RegisterTask mock is already set by Set")
	}

	expectation := &TasksServiceMockRegisterTaskExpectation{
		mock:               mmRegisterTask.mock,
		params:             &TasksServiceMockRegisterTaskParams{ctx, title},
		expectationOrigins: TasksServiceMockRegisterTaskExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterTask.expectations = append(mmRegisterTask.expectations, expectation)
	return expectation
}

// Then sets up TasksService.RegisterTask return parameters for the expectation previously defined by the When method
func (e *TasksServiceMockRegisterTaskExpectation) Then(s1 string, err error) *TasksServiceMock {
	e.results = &TasksServiceMockRegisterTaskResults{s1, err}
	return e.mock
}

// Times sets number of times TasksService.RegisterTask should be invoked
func (mmRegisterTask *mTasksServiceMockRegisterTask) Times(n uint64) *mTasksServiceMockRegisterTask {
	if n == 0 {
		mmRegisterTask.mock.t.Fatalf("Times of TasksServiceMock.RegisterTask mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterTask.expectedInvocations, n)
	mmRegisterTask.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterTask
}

func (mmRegisterTask *mTasksServiceMockRegisterTask) invocationsDone() bool {
	if len(mmRegisterTask.expectations) == 0 && mmRegisterTask.defaultExpectation == nil && mmRegisterTask.mock.funcRegisterTask == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterTask.mock.afterRegisterTaskCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterTask.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterTask implements mm_handlers.TasksService
func (mmRegisterTask *TasksServiceMock) RegisterTask(ctx context.Context, title string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmRegisterTask.beforeRegisterTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterTask.afterRegisterTaskCounter, 1)

	mmRegisterTask.t.Helper()

	if mmRegisterTask.inspectFuncRegisterTask != nil {
		mmRegisterTask.inspectFuncRegisterTask(ctx, title)
	}

	mm_params := TasksServiceMockRegisterTaskParams{ctx, title}

	// Record call args
	mmRegisterTask.RegisterTaskMock.mutex.Lock()
	mmRegisterTask.RegisterTaskMock.callArgs = append(mmRegisterTask.RegisterTaskMock.callArgs, &mm_params)
	mmRegisterTask.RegisterTaskMock.mutex.Unlock()

	for _, e := range mmRegisterTask.RegisterTaskMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmRegisterTask.RegisterTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterTask.RegisterTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterTask.RegisterTaskMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterTask.RegisterTaskMock.defaultExpectation.paramPtrs

		mm_got := TasksServiceMockRegisterTaskParams{ctx, title}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRegisterTask.t.Errorf("TasksServiceMock.RegisterTask got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterTask.RegisterTaskMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.title != nil && !minimock.Equal(*mm_want_ptrs.title, mm_got.title) {
				mmRegisterTask.t.Errorf("TasksServiceMock.RegisterTask got unexpected parameter title, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterTask.RegisterTaskMock.defaultExpectation.expectationOrigins.originTitle, *mm_want_ptrs.title, mm_got.title, minimock.Diff(*mm_want_ptrs.title, mm_got.title))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterTask.t.Errorf("TasksServiceMock.RegisterTask got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterTask.RegisterTaskMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterTask.RegisterTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterTask.t.Fatal("No results are set for the TasksServiceMock.RegisterTask")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmRegisterTask.funcRegisterTask != nil {
		return mmRegisterTask.funcRegisterTask(ctx, title)
	}
	mmRegisterTask.t.Fatalf("Unexpected call to TasksServiceMock.RegisterTask. %v %v", ctx, title)
	return
}

// RegisterTaskAfterCounter returns a count of finished TasksServiceMock.RegisterTask invocations
func (mmRegisterTask *TasksServiceMock) RegisterTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterTask.afterRegisterTaskCounter)
}

// RegisterTaskBeforeCounter returns a count of TasksServiceMock.RegisterTask invocations
func (mmRegisterTask *TasksServiceMock) RegisterTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterTask.beforeRegisterTaskCounter)
}

// Calls returns a list of arguments used in each call to TasksServiceMock.RegisterTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterTask *mTasksServiceMockRegisterTask) Calls() []*TasksServiceMockRegisterTaskParams {
	mmRegisterTask.mutex.RLock()

	argCopy := make([]*TasksServiceMockRegisterTaskParams, len(mmRegisterTask.callArgs))
	copy(argCopy, mmRegisterTask.callArgs)

	mmRegisterTask.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterTaskDone returns true if the count of the RegisterTask invocations corresponds
// the number of defined expectations
func (m *TasksServiceMock) MinimockRegisterTaskDone() bool {
	if m.RegisterTaskMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterTaskMock.invocationsDone()
}

// MinimockRegisterTaskInspect logs each unmet expectation
func (m *TasksServiceMock) MinimockRegisterTaskInspect() {
	for _, e := range m.RegisterTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TasksServiceMock.RegisterTask at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterTaskCounter := mm_atomic.LoadUint64(&m.afterRegisterTaskCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterTaskMock.defaultExpectation != nil && afterRegisterTaskCounter < 1 {
		if m.RegisterTaskMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TasksServiceMock.RegisterTask at\n%s", m.RegisterTaskMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TasksServiceMock.RegisterTask at\n%s with params: %#v", m.RegisterTaskMock.defaultExpectation.expectationOrigins.origin, *m.RegisterTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterTask != nil && afterRegisterTaskCounter < 1 {
		m.t.Errorf("Expected call to TasksServiceMock.RegisterTask at\n%s", m.funcRegisterTaskOrigin)
	}

	if !m.RegisterTaskMock.invocationsDone() && afterRegisterTaskCounter > 0 {
		m.t.Errorf("Expected %d calls to TasksServiceMock.RegisterTask at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterTaskMock.expectedInvocations), m.RegisterTaskMock.expectedInvocationsOrigin, afterRegisterTaskCounter)
	}
}

type mTasksServiceMockTaskInfo struct {
	optional           bool
	mock               *TasksServiceMock
	defaultExpectation *TasksServiceMockTaskInfoExpectation
	expectations       []*TasksServiceMockTaskInfoExpectation

	callArgs []*TasksServiceMockTaskInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TasksServiceMockTaskInfoExpectation specifies expectation struct of the TasksService.TaskInfo
type TasksServiceMockTaskInfoExpectation struct {
	mock               *TasksServiceMock
	params             *TasksServiceMockTaskInfoParams
	paramPtrs          *TasksServiceMockTaskInfoParamPtrs
	expectationOrigins TasksServiceMockTaskInfoExpectationOrigins
	results            *TasksServiceMockTaskInfoResults
	returnOrigin       string
	Counter            uint64
}

// TasksServiceMockTaskInfoParams contains parameters of the TasksService.TaskInfo
type TasksServiceMockTaskInfoParams struct {
	ctx    context.Context
	taskId string
}

// TasksServiceMockTaskInfoParamPtrs contains pointers to parameters of the TasksService.TaskInfo
type TasksServiceMockTaskInfoParamPtrs struct {
	ctx    *context.Context
	taskId *string
}

// TasksServiceMockTaskInfoResults contains results of the TasksService.TaskInfo
type TasksServiceMockTaskInfoResults struct {
	tp1 *model.Task
	err error
}

// TasksServiceMockTaskInfoOrigins contains origins of expectations of the TasksService.TaskInfo
type TasksServiceMockTaskInfoExpectationOrigins struct {
	origin       string
	originCtx    string
	originTaskId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTaskInfo *mTasksServiceMockTaskInfo) Optional() *mTasksServiceMockTaskInfo {
	mmTaskInfo.optional = true
	return mmTaskInfo
}

// Expect sets up expected params for TasksService.TaskInfo
func (mmTaskInfo *mTasksServiceMockTaskInfo) Expect(ctx context.Context, taskId string) *mTasksServiceMockTaskInfo {
	if mmTaskInfo.mock.funcTaskInfo != nil {
		mmTaskInfo.mock.t.Fatalf("TasksServiceMock.TaskInfo mock is already set by Set")
	}

	if mmTaskInfo.defaultExpectation == nil {
		mmTaskInfo.defaultExpectation = &TasksServiceMockTaskInfoExpectation{}
	}

	if mmTaskInfo.defaultExpectation.paramPtrs != nil {
		mmTaskInfo.mock.t.Fatalf("TasksServiceMock.TaskInfo mock is already set by ExpectParams functions")
	}

	mmTaskInfo.defaultExpectation.params = &TasksServiceMockTaskInfoParams{ctx, taskId}
	mmTaskInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTaskInfo.expectations {
		if minimock.Equal(e.params, mmTaskInfo.defaultExpectation.params) {
			mmTaskInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTaskInfo.defaultExpectation.params)
		}
	}

	return mmTaskInfo
}

// ExpectCtxParam1 sets up expected param ctx for TasksService.TaskInfo
func (mmTaskInfo *mTasksServiceMockTaskInfo) ExpectCtxParam1(ctx context.Context) *mTasksServiceMockTaskInfo {
	if mmTaskInfo.mock.funcTaskInfo != nil {
		mmTaskInfo.mock.t.Fatalf("TasksServiceMock.TaskInfo mock is already set by Set")
	}

	if mmTaskInfo.defaultExpectation == nil {
		mmTaskInfo.defaultExpectation = &TasksServiceMockTaskInfoExpectation{}
	}

	if mmTaskInfo.defaultExpectation.params != nil {
		mmTaskInfo.mock.t.Fatalf("TasksServiceMock.TaskInfo mock is already set by Expect")
	}

	if mmTaskInfo.defaultExpectation.paramPtrs == nil {
		mmTaskInfo.defaultExpectation.paramPtrs = &TasksServiceMockTaskInfoParamPtrs{}
	}
	mmTaskInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmTaskInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTaskInfo
}

// ExpectTaskIdParam2 sets up expected param taskId for TasksService.TaskInfo
func (mmTaskInfo *mTasksServiceMockTaskInfo) ExpectTaskIdParam2(taskId string) *mTasksServiceMockTaskInfo {
	if mmTaskInfo.mock.funcTaskInfo != nil {
		mmTaskInfo.mock.t.Fatalf("TasksServiceMock.TaskInfo mock is already set by Set")
	}

	if mmTaskInfo.defaultExpectation == nil {
		mmTaskInfo.defaultExpectation = &TasksServiceMockTaskInfoExpectation{}
	}

	if mmTaskInfo.defaultExpectation.params != nil {
		mmTaskInfo.mock.t.Fatalf("TasksServiceMock.TaskInfo mock is already set by Expect")
	}

	if mmTaskInfo.defaultExpectation.paramPtrs == nil {
		mmTaskInfo.defaultExpectation.paramPtrs = &TasksServiceMockTaskInfoParamPtrs{}
	}
	mmTaskInfo.defaultExpectation.paramPtrs.taskId = &taskId
	mmTaskInfo.defaultExpectation.expectationOrigins.originTaskId = minimock.CallerInfo(1)

	return mmTaskInfo
}

// Inspect accepts an inspector function that has same arguments as the TasksService.TaskInfo
func (mmTaskInfo *mTasksServiceMockTaskInfo) Inspect(f func(ctx context.Context, taskId string)) *mTasksServiceMockTaskInfo {
	if mmTaskInfo.mock.inspectFuncTaskInfo != nil {
		mmTaskInfo.mock.t.Fatalf("Inspect function is already set for TasksServiceMock.TaskInfo")
	}

	mmTaskInfo.mock.inspectFuncTaskInfo = f

	return mmTaskInfo
}

// Return sets up results that will be returned by TasksService.TaskInfo
func (mmTaskInfo *mTasksServiceMockTaskInfo) Return(tp1 *model.Task, err error) *TasksServiceMock {
	if mmTaskInfo.mock.funcTaskInfo != nil {
		mmTaskInfo.mock.t.Fatalf("TasksServiceMock.TaskInfo mock is already set by Set")
	}

	if mmTaskInfo.defaultExpectation == nil {
		mmTaskInfo.defaultExpectation = &TasksServiceMockTaskInfoExpectation{mock: mmTaskInfo.mock}
	}
	mmTaskInfo.defaultExpectation.results = &TasksServiceMockTaskInfoResults{tp1, err}
	mmTaskInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTaskInfo.mock
}

// Set uses given function f to mock the TasksService.TaskInfo method
func (mmTaskInfo *mTasksServiceMockTaskInfo) Set(f func(ctx context.Context, taskId string) (tp1 *model.Task, err error)) *TasksServiceMock {
	if mmTaskInfo.defaultExpectation != nil {
		mmTaskInfo.mock.t.Fatalf("Default expectation is already set for the TasksService.TaskInfo method")
	}

	if len(mmTaskInfo.expectations) > 0 {
		mmTaskInfo.mock.t.Fatalf("Some expectations are already set for the TasksService.TaskInfo method")
	}

	mmTaskInfo.mock.funcTaskInfo = f
	mmTaskInfo.mock.funcTaskInfoOrigin = minimock.CallerInfo(1)
	return mmTaskInfo.mock
}

// When sets expectation for the TasksService.TaskInfo which will trigger the result defined by the following
// Then helper
func (mmTaskInfo *mTasksServiceMockTaskInfo) When(ctx context.Context, taskId string) *TasksServiceMockTaskInfoExpectation {
	if mmTaskInfo.mock.funcTaskInfo != nil {
		mmTaskInfo.mock.t.Fatalf("TasksServiceMock.TaskInfo mock is already set by Set")
	}

	expectation := &TasksServiceMockTaskInfoExpectation{
		mock:               mmTaskInfo.mock,
		params:             &TasksServiceMockTaskInfoParams{ctx, taskId},
		expectationOrigins: TasksServiceMockTaskInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTaskInfo.expectations = append(mmTaskInfo.expectations, expectation)
	return expectation
}

// Then sets up TasksService.TaskInfo return parameters for the expectation previously defined by the When method
func (e *TasksServiceMockTaskInfoExpectation) Then(tp1 *model.Task, err error) *TasksServiceMock {
	e.results = &TasksServiceMockTaskInfoResults{tp1, err}
	return e.mock
}

// Times sets number of times TasksService.TaskInfo should be invoked
func (mmTaskInfo *mTasksServiceMockTaskInfo) Times(n uint64) *mTasksServiceMockTaskInfo {
	if n == 0 {
		mmTaskInfo.mock.t.Fatalf("Times of TasksServiceMock.TaskInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTaskInfo.expectedInvocations, n)
	mmTaskInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTaskInfo
}

func (mmTaskInfo *mTasksServiceMockTaskInfo) invocationsDone() bool {
	if len(mmTaskInfo.expectations) == 0 && mmTaskInfo.defaultExpectation == nil && mmTaskInfo.mock.funcTaskInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTaskInfo.mock.afterTaskInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTaskInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TaskInfo implements mm_handlers.TasksService
func (mmTaskInfo *TasksServiceMock) TaskInfo(ctx context.Context, taskId string) (tp1 *model.Task, err error) {
	mm_atomic.AddUint64(&mmTaskInfo.beforeTaskInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmTaskInfo.afterTaskInfoCounter, 1)

	mmTaskInfo.t.Helper()

	if mmTaskInfo.inspectFuncTaskInfo != nil {
		mmTaskInfo.inspectFuncTaskInfo(ctx, taskId)
	}

	mm_params := TasksServiceMockTaskInfoParams{ctx, taskId}

	// Record call args
	mmTaskInfo.TaskInfoMock.mutex.Lock()
	mmTaskInfo.TaskInfoMock.callArgs = append(mmTaskInfo.TaskInfoMock.callArgs, &mm_params)
	mmTaskInfo.TaskInfoMock.mutex.Unlock()

	for _, e := range mmTaskInfo.TaskInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmTaskInfo.TaskInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTaskInfo.TaskInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmTaskInfo.TaskInfoMock.defaultExpectation.params
		mm_want_ptrs := mmTaskInfo.TaskInfoMock.defaultExpectation.paramPtrs

		mm_got := TasksServiceMockTaskInfoParams{ctx, taskId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTaskInfo.t.Errorf("TasksServiceMock.TaskInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTaskInfo.TaskInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.taskId != nil && !minimock.Equal(*mm_want_ptrs.taskId, mm_got.taskId) {
				mmTaskInfo.t.Errorf("TasksServiceMock.TaskInfo got unexpected parameter taskId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTaskInfo.TaskInfoMock.defaultExpectation.expectationOrigins.originTaskId, *mm_want_ptrs.taskId, mm_got.taskId, minimock.Diff(*mm_want_ptrs.taskId, mm_got.taskId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTaskInfo.t.Errorf("TasksServiceMock.TaskInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTaskInfo.TaskInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTaskInfo.TaskInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmTaskInfo.t.Fatal("No results are set for the TasksServiceMock.TaskInfo")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmTaskInfo.funcTaskInfo != nil {
		return mmTaskInfo.funcTaskInfo(ctx, taskId)
	}
	mmTaskInfo.t.Fatalf("Unexpected call to TasksServiceMock.TaskInfo. %v %v", ctx, taskId)
	return
}

// TaskInfoAfterCounter returns a count of finished TasksServiceMock.TaskInfo invocations
func (mmTaskInfo *TasksServiceMock) TaskInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTaskInfo.afterTaskInfoCounter)
}

// TaskInfoBeforeCounter returns a count of TasksServiceMock.TaskInfo invocations
func (mmTaskInfo *TasksServiceMock) TaskInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTaskInfo.beforeTaskInfoCounter)
}

// Calls returns a list of arguments used in each call to TasksServiceMock.TaskInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTaskInfo *mTasksServiceMockTaskInfo) Calls() []*TasksServiceMockTaskInfoParams {
	mmTaskInfo.mutex.RLock()

	argCopy := make([]*TasksServiceMockTaskInfoParams, len(mmTaskInfo.callArgs))
	copy(argCopy, mmTaskInfo.callArgs)

	mmTaskInfo.mutex.RUnlock()

	return argCopy
}

// MinimockTaskInfoDone returns true if the count of the TaskInfo invocations corresponds
// the number of defined expectations
func (m *TasksServiceMock) MinimockTaskInfoDone() bool {
	if m.TaskInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TaskInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TaskInfoMock.invocationsDone()
}

// MinimockTaskInfoInspect logs each unmet expectation
func (m *TasksServiceMock) MinimockTaskInfoInspect() {
	for _, e := range m.TaskInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TasksServiceMock.TaskInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTaskInfoCounter := mm_atomic.LoadUint64(&m.afterTaskInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TaskInfoMock.defaultExpectation != nil && afterTaskInfoCounter < 1 {
		if m.TaskInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TasksServiceMock.TaskInfo at\n%s", m.TaskInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TasksServiceMock.TaskInfo at\n%s with params: %#v", m.TaskInfoMock.defaultExpectation.expectationOrigins.origin, *m.TaskInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTaskInfo != nil && afterTaskInfoCounter < 1 {
		m.t.Errorf("Expected call to TasksServiceMock.TaskInfo at\n%s", m.funcTaskInfoOrigin)
	}

	if !m.TaskInfoMock.invocationsDone() && afterTaskInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to TasksServiceMock.TaskInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TaskInfoMock.expectedInvocations), m.TaskInfoMock.expectedInvocationsOrigin, afterTaskInfoCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TasksServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteTaskInspect()

			m.MinimockRegisterTaskInspect()

			m.MinimockTaskInfoInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TasksServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TasksServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteTaskDone() &&
		m.MinimockRegisterTaskDone() &&
		m.MinimockTaskInfoDone()
}
