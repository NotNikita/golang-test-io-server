// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i test-server/internal/domain/task/service.TasksRepository -o tasks_repository_mock.go -n TasksRepositoryMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"test-server/internal/domain/model"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// TasksRepositoryMock implements mm_service.TasksRepository
type TasksRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateTask          func(ctx context.Context, task model.Task) (err error)
	funcCreateTaskOrigin    string
	inspectFuncCreateTask   func(ctx context.Context, task model.Task)
	afterCreateTaskCounter  uint64
	beforeCreateTaskCounter uint64
	CreateTaskMock          mTasksRepositoryMockCreateTask

	funcDeleteTask          func(ctx context.Context, id string) (err error)
	funcDeleteTaskOrigin    string
	inspectFuncDeleteTask   func(ctx context.Context, id string)
	afterDeleteTaskCounter  uint64
	beforeDeleteTaskCounter uint64
	DeleteTaskMock          mTasksRepositoryMockDeleteTask

	funcGetTask          func(ctx context.Context, id string) (tp1 *model.Task, err error)
	funcGetTaskOrigin    string
	inspectFuncGetTask   func(ctx context.Context, id string)
	afterGetTaskCounter  uint64
	beforeGetTaskCounter uint64
	GetTaskMock          mTasksRepositoryMockGetTask

	funcUpdateTask          func(ctx context.Context, id string, status model.Status) (err error)
	funcUpdateTaskOrigin    string
	inspectFuncUpdateTask   func(ctx context.Context, id string, status model.Status)
	afterUpdateTaskCounter  uint64
	beforeUpdateTaskCounter uint64
	UpdateTaskMock          mTasksRepositoryMockUpdateTask
}

// NewTasksRepositoryMock returns a mock for mm_service.TasksRepository
func NewTasksRepositoryMock(t minimock.Tester) *TasksRepositoryMock {
	m := &TasksRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateTaskMock = mTasksRepositoryMockCreateTask{mock: m}
	m.CreateTaskMock.callArgs = []*TasksRepositoryMockCreateTaskParams{}

	m.DeleteTaskMock = mTasksRepositoryMockDeleteTask{mock: m}
	m.DeleteTaskMock.callArgs = []*TasksRepositoryMockDeleteTaskParams{}

	m.GetTaskMock = mTasksRepositoryMockGetTask{mock: m}
	m.GetTaskMock.callArgs = []*TasksRepositoryMockGetTaskParams{}

	m.UpdateTaskMock = mTasksRepositoryMockUpdateTask{mock: m}
	m.UpdateTaskMock.callArgs = []*TasksRepositoryMockUpdateTaskParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTasksRepositoryMockCreateTask struct {
	optional           bool
	mock               *TasksRepositoryMock
	defaultExpectation *TasksRepositoryMockCreateTaskExpectation
	expectations       []*TasksRepositoryMockCreateTaskExpectation

	callArgs []*TasksRepositoryMockCreateTaskParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TasksRepositoryMockCreateTaskExpectation specifies expectation struct of the TasksRepository.CreateTask
type TasksRepositoryMockCreateTaskExpectation struct {
	mock               *TasksRepositoryMock
	params             *TasksRepositoryMockCreateTaskParams
	paramPtrs          *TasksRepositoryMockCreateTaskParamPtrs
	expectationOrigins TasksRepositoryMockCreateTaskExpectationOrigins
	results            *TasksRepositoryMockCreateTaskResults
	returnOrigin       string
	Counter            uint64
}

// TasksRepositoryMockCreateTaskParams contains parameters of the TasksRepository.CreateTask
type TasksRepositoryMockCreateTaskParams struct {
	ctx  context.Context
	task model.Task
}

// TasksRepositoryMockCreateTaskParamPtrs contains pointers to parameters of the TasksRepository.CreateTask
type TasksRepositoryMockCreateTaskParamPtrs struct {
	ctx  *context.Context
	task *model.Task
}

// TasksRepositoryMockCreateTaskResults contains results of the TasksRepository.CreateTask
type TasksRepositoryMockCreateTaskResults struct {
	err error
}

// TasksRepositoryMockCreateTaskOrigins contains origins of expectations of the TasksRepository.CreateTask
type TasksRepositoryMockCreateTaskExpectationOrigins struct {
	origin     string
	originCtx  string
	originTask string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateTask *mTasksRepositoryMockCreateTask) Optional() *mTasksRepositoryMockCreateTask {
	mmCreateTask.optional = true
	return mmCreateTask
}

// Expect sets up expected params for TasksRepository.CreateTask
func (mmCreateTask *mTasksRepositoryMockCreateTask) Expect(ctx context.Context, task model.Task) *mTasksRepositoryMockCreateTask {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("TasksRepositoryMock.CreateTask mock is already set by Set")
	}

	if mmCreateTask.defaultExpectation == nil {
		mmCreateTask.defaultExpectation = &TasksRepositoryMockCreateTaskExpectation{}
	}

	if mmCreateTask.defaultExpectation.paramPtrs != nil {
		mmCreateTask.mock.t.Fatalf("TasksRepositoryMock.CreateTask mock is already set by ExpectParams functions")
	}

	mmCreateTask.defaultExpectation.params = &TasksRepositoryMockCreateTaskParams{ctx, task}
	mmCreateTask.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateTask.expectations {
		if minimock.Equal(e.params, mmCreateTask.defaultExpectation.params) {
			mmCreateTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTask.defaultExpectation.params)
		}
	}

	return mmCreateTask
}

// ExpectCtxParam1 sets up expected param ctx for TasksRepository.CreateTask
func (mmCreateTask *mTasksRepositoryMockCreateTask) ExpectCtxParam1(ctx context.Context) *mTasksRepositoryMockCreateTask {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("TasksRepositoryMock.CreateTask mock is already set by Set")
	}

	if mmCreateTask.defaultExpectation == nil {
		mmCreateTask.defaultExpectation = &TasksRepositoryMockCreateTaskExpectation{}
	}

	if mmCreateTask.defaultExpectation.params != nil {
		mmCreateTask.mock.t.Fatalf("TasksRepositoryMock.CreateTask mock is already set by Expect")
	}

	if mmCreateTask.defaultExpectation.paramPtrs == nil {
		mmCreateTask.defaultExpectation.paramPtrs = &TasksRepositoryMockCreateTaskParamPtrs{}
	}
	mmCreateTask.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateTask.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateTask
}

// ExpectTaskParam2 sets up expected param task for TasksRepository.CreateTask
func (mmCreateTask *mTasksRepositoryMockCreateTask) ExpectTaskParam2(task model.Task) *mTasksRepositoryMockCreateTask {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("TasksRepositoryMock.CreateTask mock is already set by Set")
	}

	if mmCreateTask.defaultExpectation == nil {
		mmCreateTask.defaultExpectation = &TasksRepositoryMockCreateTaskExpectation{}
	}

	if mmCreateTask.defaultExpectation.params != nil {
		mmCreateTask.mock.t.Fatalf("TasksRepositoryMock.CreateTask mock is already set by Expect")
	}

	if mmCreateTask.defaultExpectation.paramPtrs == nil {
		mmCreateTask.defaultExpectation.paramPtrs = &TasksRepositoryMockCreateTaskParamPtrs{}
	}
	mmCreateTask.defaultExpectation.paramPtrs.task = &task
	mmCreateTask.defaultExpectation.expectationOrigins.originTask = minimock.CallerInfo(1)

	return mmCreateTask
}

// Inspect accepts an inspector function that has same arguments as the TasksRepository.CreateTask
func (mmCreateTask *mTasksRepositoryMockCreateTask) Inspect(f func(ctx context.Context, task model.Task)) *mTasksRepositoryMockCreateTask {
	if mmCreateTask.mock.inspectFuncCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("Inspect function is already set for TasksRepositoryMock.CreateTask")
	}

	mmCreateTask.mock.inspectFuncCreateTask = f

	return mmCreateTask
}

// Return sets up results that will be returned by TasksRepository.CreateTask
func (mmCreateTask *mTasksRepositoryMockCreateTask) Return(err error) *TasksRepositoryMock {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("TasksRepositoryMock.CreateTask mock is already set by Set")
	}

	if mmCreateTask.defaultExpectation == nil {
		mmCreateTask.defaultExpectation = &TasksRepositoryMockCreateTaskExpectation{mock: mmCreateTask.mock}
	}
	mmCreateTask.defaultExpectation.results = &TasksRepositoryMockCreateTaskResults{err}
	mmCreateTask.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateTask.mock
}

// Set uses given function f to mock the TasksRepository.CreateTask method
func (mmCreateTask *mTasksRepositoryMockCreateTask) Set(f func(ctx context.Context, task model.Task) (err error)) *TasksRepositoryMock {
	if mmCreateTask.defaultExpectation != nil {
		mmCreateTask.mock.t.Fatalf("Default expectation is already set for the TasksRepository.CreateTask method")
	}

	if len(mmCreateTask.expectations) > 0 {
		mmCreateTask.mock.t.Fatalf("Some expectations are already set for the TasksRepository.CreateTask method")
	}

	mmCreateTask.mock.funcCreateTask = f
	mmCreateTask.mock.funcCreateTaskOrigin = minimock.CallerInfo(1)
	return mmCreateTask.mock
}

// When sets expectation for the TasksRepository.CreateTask which will trigger the result defined by the following
// Then helper
func (mmCreateTask *mTasksRepositoryMockCreateTask) When(ctx context.Context, task model.Task) *TasksRepositoryMockCreateTaskExpectation {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("TasksRepositoryMock.CreateTask mock is already set by Set")
	}

	expectation := &TasksRepositoryMockCreateTaskExpectation{
		mock:               mmCreateTask.mock,
		params:             &TasksRepositoryMockCreateTaskParams{ctx, task},
		expectationOrigins: TasksRepositoryMockCreateTaskExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateTask.expectations = append(mmCreateTask.expectations, expectation)
	return expectation
}

// Then sets up TasksRepository.CreateTask return parameters for the expectation previously defined by the When method
func (e *TasksRepositoryMockCreateTaskExpectation) Then(err error) *TasksRepositoryMock {
	e.results = &TasksRepositoryMockCreateTaskResults{err}
	return e.mock
}

// Times sets number of times TasksRepository.CreateTask should be invoked
func (mmCreateTask *mTasksRepositoryMockCreateTask) Times(n uint64) *mTasksRepositoryMockCreateTask {
	if n == 0 {
		mmCreateTask.mock.t.Fatalf("Times of TasksRepositoryMock.CreateTask mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateTask.expectedInvocations, n)
	mmCreateTask.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateTask
}

func (mmCreateTask *mTasksRepositoryMockCreateTask) invocationsDone() bool {
	if len(mmCreateTask.expectations) == 0 && mmCreateTask.defaultExpectation == nil && mmCreateTask.mock.funcCreateTask == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateTask.mock.afterCreateTaskCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateTask.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateTask implements mm_service.TasksRepository
func (mmCreateTask *TasksRepositoryMock) CreateTask(ctx context.Context, task model.Task) (err error) {
	mm_atomic.AddUint64(&mmCreateTask.beforeCreateTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTask.afterCreateTaskCounter, 1)

	mmCreateTask.t.Helper()

	if mmCreateTask.inspectFuncCreateTask != nil {
		mmCreateTask.inspectFuncCreateTask(ctx, task)
	}

	mm_params := TasksRepositoryMockCreateTaskParams{ctx, task}

	// Record call args
	mmCreateTask.CreateTaskMock.mutex.Lock()
	mmCreateTask.CreateTaskMock.callArgs = append(mmCreateTask.CreateTaskMock.callArgs, &mm_params)
	mmCreateTask.CreateTaskMock.mutex.Unlock()

	for _, e := range mmCreateTask.CreateTaskMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateTask.CreateTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTask.CreateTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTask.CreateTaskMock.defaultExpectation.params
		mm_want_ptrs := mmCreateTask.CreateTaskMock.defaultExpectation.paramPtrs

		mm_got := TasksRepositoryMockCreateTaskParams{ctx, task}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateTask.t.Errorf("TasksRepositoryMock.CreateTask got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTask.CreateTaskMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.task != nil && !minimock.Equal(*mm_want_ptrs.task, mm_got.task) {
				mmCreateTask.t.Errorf("TasksRepositoryMock.CreateTask got unexpected parameter task, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTask.CreateTaskMock.defaultExpectation.expectationOrigins.originTask, *mm_want_ptrs.task, mm_got.task, minimock.Diff(*mm_want_ptrs.task, mm_got.task))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTask.t.Errorf("TasksRepositoryMock.CreateTask got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateTask.CreateTaskMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTask.CreateTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTask.t.Fatal("No results are set for the TasksRepositoryMock.CreateTask")
		}
		return (*mm_results).err
	}
	if mmCreateTask.funcCreateTask != nil {
		return mmCreateTask.funcCreateTask(ctx, task)
	}
	mmCreateTask.t.Fatalf("Unexpected call to TasksRepositoryMock.CreateTask. %v %v", ctx, task)
	return
}

// CreateTaskAfterCounter returns a count of finished TasksRepositoryMock.CreateTask invocations
func (mmCreateTask *TasksRepositoryMock) CreateTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTask.afterCreateTaskCounter)
}

// CreateTaskBeforeCounter returns a count of TasksRepositoryMock.CreateTask invocations
func (mmCreateTask *TasksRepositoryMock) CreateTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTask.beforeCreateTaskCounter)
}

// Calls returns a list of arguments used in each call to TasksRepositoryMock.CreateTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTask *mTasksRepositoryMockCreateTask) Calls() []*TasksRepositoryMockCreateTaskParams {
	mmCreateTask.mutex.RLock()

	argCopy := make([]*TasksRepositoryMockCreateTaskParams, len(mmCreateTask.callArgs))
	copy(argCopy, mmCreateTask.callArgs)

	mmCreateTask.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTaskDone returns true if the count of the CreateTask invocations corresponds
// the number of defined expectations
func (m *TasksRepositoryMock) MinimockCreateTaskDone() bool {
	if m.CreateTaskMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateTaskMock.invocationsDone()
}

// MinimockCreateTaskInspect logs each unmet expectation
func (m *TasksRepositoryMock) MinimockCreateTaskInspect() {
	for _, e := range m.CreateTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TasksRepositoryMock.CreateTask at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateTaskCounter := mm_atomic.LoadUint64(&m.afterCreateTaskCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTaskMock.defaultExpectation != nil && afterCreateTaskCounter < 1 {
		if m.CreateTaskMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TasksRepositoryMock.CreateTask at\n%s", m.CreateTaskMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TasksRepositoryMock.CreateTask at\n%s with params: %#v", m.CreateTaskMock.defaultExpectation.expectationOrigins.origin, *m.CreateTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTask != nil && afterCreateTaskCounter < 1 {
		m.t.Errorf("Expected call to TasksRepositoryMock.CreateTask at\n%s", m.funcCreateTaskOrigin)
	}

	if !m.CreateTaskMock.invocationsDone() && afterCreateTaskCounter > 0 {
		m.t.Errorf("Expected %d calls to TasksRepositoryMock.CreateTask at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateTaskMock.expectedInvocations), m.CreateTaskMock.expectedInvocationsOrigin, afterCreateTaskCounter)
	}
}

type mTasksRepositoryMockDeleteTask struct {
	optional           bool
	mock               *TasksRepositoryMock
	defaultExpectation *TasksRepositoryMockDeleteTaskExpectation
	expectations       []*TasksRepositoryMockDeleteTaskExpectation

	callArgs []*TasksRepositoryMockDeleteTaskParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TasksRepositoryMockDeleteTaskExpectation specifies expectation struct of the TasksRepository.DeleteTask
type TasksRepositoryMockDeleteTaskExpectation struct {
	mock               *TasksRepositoryMock
	params             *TasksRepositoryMockDeleteTaskParams
	paramPtrs          *TasksRepositoryMockDeleteTaskParamPtrs
	expectationOrigins TasksRepositoryMockDeleteTaskExpectationOrigins
	results            *TasksRepositoryMockDeleteTaskResults
	returnOrigin       string
	Counter            uint64
}

// TasksRepositoryMockDeleteTaskParams contains parameters of the TasksRepository.DeleteTask
type TasksRepositoryMockDeleteTaskParams struct {
	ctx context.Context
	id  string
}

// TasksRepositoryMockDeleteTaskParamPtrs contains pointers to parameters of the TasksRepository.DeleteTask
type TasksRepositoryMockDeleteTaskParamPtrs struct {
	ctx *context.Context
	id  *string
}

// TasksRepositoryMockDeleteTaskResults contains results of the TasksRepository.DeleteTask
type TasksRepositoryMockDeleteTaskResults struct {
	err error
}

// TasksRepositoryMockDeleteTaskOrigins contains origins of expectations of the TasksRepository.DeleteTask
type TasksRepositoryMockDeleteTaskExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteTask *mTasksRepositoryMockDeleteTask) Optional() *mTasksRepositoryMockDeleteTask {
	mmDeleteTask.optional = true
	return mmDeleteTask
}

// Expect sets up expected params for TasksRepository.DeleteTask
func (mmDeleteTask *mTasksRepositoryMockDeleteTask) Expect(ctx context.Context, id string) *mTasksRepositoryMockDeleteTask {
	if mmDeleteTask.mock.funcDeleteTask != nil {
		mmDeleteTask.mock.t.Fatalf("TasksRepositoryMock.DeleteTask mock is already set by Set")
	}

	if mmDeleteTask.defaultExpectation == nil {
		mmDeleteTask.defaultExpectation = &TasksRepositoryMockDeleteTaskExpectation{}
	}

	if mmDeleteTask.defaultExpectation.paramPtrs != nil {
		mmDeleteTask.mock.t.Fatalf("TasksRepositoryMock.DeleteTask mock is already set by ExpectParams functions")
	}

	mmDeleteTask.defaultExpectation.params = &TasksRepositoryMockDeleteTaskParams{ctx, id}
	mmDeleteTask.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteTask.expectations {
		if minimock.Equal(e.params, mmDeleteTask.defaultExpectation.params) {
			mmDeleteTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteTask.defaultExpectation.params)
		}
	}

	return mmDeleteTask
}

// ExpectCtxParam1 sets up expected param ctx for TasksRepository.DeleteTask
func (mmDeleteTask *mTasksRepositoryMockDeleteTask) ExpectCtxParam1(ctx context.Context) *mTasksRepositoryMockDeleteTask {
	if mmDeleteTask.mock.funcDeleteTask != nil {
		mmDeleteTask.mock.t.Fatalf("TasksRepositoryMock.DeleteTask mock is already set by Set")
	}

	if mmDeleteTask.defaultExpectation == nil {
		mmDeleteTask.defaultExpectation = &TasksRepositoryMockDeleteTaskExpectation{}
	}

	if mmDeleteTask.defaultExpectation.params != nil {
		mmDeleteTask.mock.t.Fatalf("TasksRepositoryMock.DeleteTask mock is already set by Expect")
	}

	if mmDeleteTask.defaultExpectation.paramPtrs == nil {
		mmDeleteTask.defaultExpectation.paramPtrs = &TasksRepositoryMockDeleteTaskParamPtrs{}
	}
	mmDeleteTask.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteTask.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteTask
}

// ExpectIdParam2 sets up expected param id for TasksRepository.DeleteTask
func (mmDeleteTask *mTasksRepositoryMockDeleteTask) ExpectIdParam2(id string) *mTasksRepositoryMockDeleteTask {
	if mmDeleteTask.mock.funcDeleteTask != nil {
		mmDeleteTask.mock.t.Fatalf("TasksRepositoryMock.DeleteTask mock is already set by Set")
	}

	if mmDeleteTask.defaultExpectation == nil {
		mmDeleteTask.defaultExpectation = &TasksRepositoryMockDeleteTaskExpectation{}
	}

	if mmDeleteTask.defaultExpectation.params != nil {
		mmDeleteTask.mock.t.Fatalf("TasksRepositoryMock.DeleteTask mock is already set by Expect")
	}

	if mmDeleteTask.defaultExpectation.paramPtrs == nil {
		mmDeleteTask.defaultExpectation.paramPtrs = &TasksRepositoryMockDeleteTaskParamPtrs{}
	}
	mmDeleteTask.defaultExpectation.paramPtrs.id = &id
	mmDeleteTask.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteTask
}

// Inspect accepts an inspector function that has same arguments as the TasksRepository.DeleteTask
func (mmDeleteTask *mTasksRepositoryMockDeleteTask) Inspect(f func(ctx context.Context, id string)) *mTasksRepositoryMockDeleteTask {
	if mmDeleteTask.mock.inspectFuncDeleteTask != nil {
		mmDeleteTask.mock.t.Fatalf("Inspect function is already set for TasksRepositoryMock.DeleteTask")
	}

	mmDeleteTask.mock.inspectFuncDeleteTask = f

	return mmDeleteTask
}

// Return sets up results that will be returned by TasksRepository.DeleteTask
func (mmDeleteTask *mTasksRepositoryMockDeleteTask) Return(err error) *TasksRepositoryMock {
	if mmDeleteTask.mock.funcDeleteTask != nil {
		mmDeleteTask.mock.t.Fatalf("TasksRepositoryMock.DeleteTask mock is already set by Set")
	}

	if mmDeleteTask.defaultExpectation == nil {
		mmDeleteTask.defaultExpectation = &TasksRepositoryMockDeleteTaskExpectation{mock: mmDeleteTask.mock}
	}
	mmDeleteTask.defaultExpectation.results = &TasksRepositoryMockDeleteTaskResults{err}
	mmDeleteTask.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteTask.mock
}

// Set uses given function f to mock the TasksRepository.DeleteTask method
func (mmDeleteTask *mTasksRepositoryMockDeleteTask) Set(f func(ctx context.Context, id string) (err error)) *TasksRepositoryMock {
	if mmDeleteTask.defaultExpectation != nil {
		mmDeleteTask.mock.t.Fatalf("Default expectation is already set for the TasksRepository.DeleteTask method")
	}

	if len(mmDeleteTask.expectations) > 0 {
		mmDeleteTask.mock.t.Fatalf("Some expectations are already set for the TasksRepository.DeleteTask method")
	}

	mmDeleteTask.mock.funcDeleteTask = f
	mmDeleteTask.mock.funcDeleteTaskOrigin = minimock.CallerInfo(1)
	return mmDeleteTask.mock
}

// When sets expectation for the TasksRepository.DeleteTask which will trigger the result defined by the following
// Then helper
func (mmDeleteTask *mTasksRepositoryMockDeleteTask) When(ctx context.Context, id string) *TasksRepositoryMockDeleteTaskExpectation {
	if mmDeleteTask.mock.funcDeleteTask != nil {
		mmDeleteTask.mock.t.Fatalf("TasksRepositoryMock.DeleteTask mock is already set by Set")
	}

	expectation := &TasksRepositoryMockDeleteTaskExpectation{
		mock:               mmDeleteTask.mock,
		params:             &TasksRepositoryMockDeleteTaskParams{ctx, id},
		expectationOrigins: TasksRepositoryMockDeleteTaskExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteTask.expectations = append(mmDeleteTask.expectations, expectation)
	return expectation
}

// Then sets up TasksRepository.DeleteTask return parameters for the expectation previously defined by the When method
func (e *TasksRepositoryMockDeleteTaskExpectation) Then(err error) *TasksRepositoryMock {
	e.results = &TasksRepositoryMockDeleteTaskResults{err}
	return e.mock
}

// Times sets number of times TasksRepository.DeleteTask should be invoked
func (mmDeleteTask *mTasksRepositoryMockDeleteTask) Times(n uint64) *mTasksRepositoryMockDeleteTask {
	if n == 0 {
		mmDeleteTask.mock.t.Fatalf("Times of TasksRepositoryMock.DeleteTask mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteTask.expectedInvocations, n)
	mmDeleteTask.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteTask
}

func (mmDeleteTask *mTasksRepositoryMockDeleteTask) invocationsDone() bool {
	if len(mmDeleteTask.expectations) == 0 && mmDeleteTask.defaultExpectation == nil && mmDeleteTask.mock.funcDeleteTask == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteTask.mock.afterDeleteTaskCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteTask.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteTask implements mm_service.TasksRepository
func (mmDeleteTask *TasksRepositoryMock) DeleteTask(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteTask.beforeDeleteTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteTask.afterDeleteTaskCounter, 1)

	mmDeleteTask.t.Helper()

	if mmDeleteTask.inspectFuncDeleteTask != nil {
		mmDeleteTask.inspectFuncDeleteTask(ctx, id)
	}

	mm_params := TasksRepositoryMockDeleteTaskParams{ctx, id}

	// Record call args
	mmDeleteTask.DeleteTaskMock.mutex.Lock()
	mmDeleteTask.DeleteTaskMock.callArgs = append(mmDeleteTask.DeleteTaskMock.callArgs, &mm_params)
	mmDeleteTask.DeleteTaskMock.mutex.Unlock()

	for _, e := range mmDeleteTask.DeleteTaskMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteTask.DeleteTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteTask.DeleteTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteTask.DeleteTaskMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteTask.DeleteTaskMock.defaultExpectation.paramPtrs

		mm_got := TasksRepositoryMockDeleteTaskParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteTask.t.Errorf("TasksRepositoryMock.DeleteTask got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTask.DeleteTaskMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteTask.t.Errorf("TasksRepositoryMock.DeleteTask got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTask.DeleteTaskMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteTask.t.Errorf("TasksRepositoryMock.DeleteTask got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteTask.DeleteTaskMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteTask.DeleteTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteTask.t.Fatal("No results are set for the TasksRepositoryMock.DeleteTask")
		}
		return (*mm_results).err
	}
	if mmDeleteTask.funcDeleteTask != nil {
		return mmDeleteTask.funcDeleteTask(ctx, id)
	}
	mmDeleteTask.t.Fatalf("Unexpected call to TasksRepositoryMock.DeleteTask. %v %v", ctx, id)
	return
}

// DeleteTaskAfterCounter returns a count of finished TasksRepositoryMock.DeleteTask invocations
func (mmDeleteTask *TasksRepositoryMock) DeleteTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTask.afterDeleteTaskCounter)
}

// DeleteTaskBeforeCounter returns a count of TasksRepositoryMock.DeleteTask invocations
func (mmDeleteTask *TasksRepositoryMock) DeleteTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTask.beforeDeleteTaskCounter)
}

// Calls returns a list of arguments used in each call to TasksRepositoryMock.DeleteTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteTask *mTasksRepositoryMockDeleteTask) Calls() []*TasksRepositoryMockDeleteTaskParams {
	mmDeleteTask.mutex.RLock()

	argCopy := make([]*TasksRepositoryMockDeleteTaskParams, len(mmDeleteTask.callArgs))
	copy(argCopy, mmDeleteTask.callArgs)

	mmDeleteTask.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteTaskDone returns true if the count of the DeleteTask invocations corresponds
// the number of defined expectations
func (m *TasksRepositoryMock) MinimockDeleteTaskDone() bool {
	if m.DeleteTaskMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteTaskMock.invocationsDone()
}

// MinimockDeleteTaskInspect logs each unmet expectation
func (m *TasksRepositoryMock) MinimockDeleteTaskInspect() {
	for _, e := range m.DeleteTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TasksRepositoryMock.DeleteTask at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteTaskCounter := mm_atomic.LoadUint64(&m.afterDeleteTaskCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteTaskMock.defaultExpectation != nil && afterDeleteTaskCounter < 1 {
		if m.DeleteTaskMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TasksRepositoryMock.DeleteTask at\n%s", m.DeleteTaskMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TasksRepositoryMock.DeleteTask at\n%s with params: %#v", m.DeleteTaskMock.defaultExpectation.expectationOrigins.origin, *m.DeleteTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteTask != nil && afterDeleteTaskCounter < 1 {
		m.t.Errorf("Expected call to TasksRepositoryMock.DeleteTask at\n%s", m.funcDeleteTaskOrigin)
	}

	if !m.DeleteTaskMock.invocationsDone() && afterDeleteTaskCounter > 0 {
		m.t.Errorf("Expected %d calls to TasksRepositoryMock.DeleteTask at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteTaskMock.expectedInvocations), m.DeleteTaskMock.expectedInvocationsOrigin, afterDeleteTaskCounter)
	}
}

type mTasksRepositoryMockGetTask struct {
	optional           bool
	mock               *TasksRepositoryMock
	defaultExpectation *TasksRepositoryMockGetTaskExpectation
	expectations       []*TasksRepositoryMockGetTaskExpectation

	callArgs []*TasksRepositoryMockGetTaskParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TasksRepositoryMockGetTaskExpectation specifies expectation struct of the TasksRepository.GetTask
type TasksRepositoryMockGetTaskExpectation struct {
	mock               *TasksRepositoryMock
	params             *TasksRepositoryMockGetTaskParams
	paramPtrs          *TasksRepositoryMockGetTaskParamPtrs
	expectationOrigins TasksRepositoryMockGetTaskExpectationOrigins
	results            *TasksRepositoryMockGetTaskResults
	returnOrigin       string
	Counter            uint64
}

// TasksRepositoryMockGetTaskParams contains parameters of the TasksRepository.GetTask
type TasksRepositoryMockGetTaskParams struct {
	ctx context.Context
	id  string
}

// TasksRepositoryMockGetTaskParamPtrs contains pointers to parameters of the TasksRepository.GetTask
type TasksRepositoryMockGetTaskParamPtrs struct {
	ctx *context.Context
	id  *string
}

// TasksRepositoryMockGetTaskResults contains results of the TasksRepository.GetTask
type TasksRepositoryMockGetTaskResults struct {
	tp1 *model.Task
	err error
}

// TasksRepositoryMockGetTaskOrigins contains origins of expectations of the TasksRepository.GetTask
type TasksRepositoryMockGetTaskExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTask *mTasksRepositoryMockGetTask) Optional() *mTasksRepositoryMockGetTask {
	mmGetTask.optional = true
	return mmGetTask
}

// Expect sets up expected params for TasksRepository.GetTask
func (mmGetTask *mTasksRepositoryMockGetTask) Expect(ctx context.Context, id string) *mTasksRepositoryMockGetTask {
	if mmGetTask.mock.funcGetTask != nil {
		mmGetTask.mock.t.Fatalf("TasksRepositoryMock.GetTask mock is already set by Set")
	}

	if mmGetTask.defaultExpectation == nil {
		mmGetTask.defaultExpectation = &TasksRepositoryMockGetTaskExpectation{}
	}

	if mmGetTask.defaultExpectation.paramPtrs != nil {
		mmGetTask.mock.t.Fatalf("TasksRepositoryMock.GetTask mock is already set by ExpectParams functions")
	}

	mmGetTask.defaultExpectation.params = &TasksRepositoryMockGetTaskParams{ctx, id}
	mmGetTask.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTask.expectations {
		if minimock.Equal(e.params, mmGetTask.defaultExpectation.params) {
			mmGetTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTask.defaultExpectation.params)
		}
	}

	return mmGetTask
}

// ExpectCtxParam1 sets up expected param ctx for TasksRepository.GetTask
func (mmGetTask *mTasksRepositoryMockGetTask) ExpectCtxParam1(ctx context.Context) *mTasksRepositoryMockGetTask {
	if mmGetTask.mock.funcGetTask != nil {
		mmGetTask.mock.t.Fatalf("TasksRepositoryMock.GetTask mock is already set by Set")
	}

	if mmGetTask.defaultExpectation == nil {
		mmGetTask.defaultExpectation = &TasksRepositoryMockGetTaskExpectation{}
	}

	if mmGetTask.defaultExpectation.params != nil {
		mmGetTask.mock.t.Fatalf("TasksRepositoryMock.GetTask mock is already set by Expect")
	}

	if mmGetTask.defaultExpectation.paramPtrs == nil {
		mmGetTask.defaultExpectation.paramPtrs = &TasksRepositoryMockGetTaskParamPtrs{}
	}
	mmGetTask.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTask.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTask
}

// ExpectIdParam2 sets up expected param id for TasksRepository.GetTask
func (mmGetTask *mTasksRepositoryMockGetTask) ExpectIdParam2(id string) *mTasksRepositoryMockGetTask {
	if mmGetTask.mock.funcGetTask != nil {
		mmGetTask.mock.t.Fatalf("TasksRepositoryMock.GetTask mock is already set by Set")
	}

	if mmGetTask.defaultExpectation == nil {
		mmGetTask.defaultExpectation = &TasksRepositoryMockGetTaskExpectation{}
	}

	if mmGetTask.defaultExpectation.params != nil {
		mmGetTask.mock.t.Fatalf("TasksRepositoryMock.GetTask mock is already set by Expect")
	}

	if mmGetTask.defaultExpectation.paramPtrs == nil {
		mmGetTask.defaultExpectation.paramPtrs = &TasksRepositoryMockGetTaskParamPtrs{}
	}
	mmGetTask.defaultExpectation.paramPtrs.id = &id
	mmGetTask.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetTask
}

// Inspect accepts an inspector function that has same arguments as the TasksRepository.GetTask
func (mmGetTask *mTasksRepositoryMockGetTask) Inspect(f func(ctx context.Context, id string)) *mTasksRepositoryMockGetTask {
	if mmGetTask.mock.inspectFuncGetTask != nil {
		mmGetTask.mock.t.Fatalf("Inspect function is already set for TasksRepositoryMock.GetTask")
	}

	mmGetTask.mock.inspectFuncGetTask = f

	return mmGetTask
}

// Return sets up results that will be returned by TasksRepository.GetTask
func (mmGetTask *mTasksRepositoryMockGetTask) Return(tp1 *model.Task, err error) *TasksRepositoryMock {
	if mmGetTask.mock.funcGetTask != nil {
		mmGetTask.mock.t.Fatalf("TasksRepositoryMock.GetTask mock is already set by Set")
	}

	if mmGetTask.defaultExpectation == nil {
		mmGetTask.defaultExpectation = &TasksRepositoryMockGetTaskExpectation{mock: mmGetTask.mock}
	}
	mmGetTask.defaultExpectation.results = &TasksRepositoryMockGetTaskResults{tp1, err}
	mmGetTask.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTask.mock
}

// Set uses given function f to mock the TasksRepository.GetTask method
func (mmGetTask *mTasksRepositoryMockGetTask) Set(f func(ctx context.Context, id string) (tp1 *model.Task, err error)) *TasksRepositoryMock {
	if mmGetTask.defaultExpectation != nil {
		mmGetTask.mock.t.Fatalf("Default expectation is already set for the TasksRepository.GetTask method")
	}

	if len(mmGetTask.expectations) > 0 {
		mmGetTask.mock.t.Fatalf("Some expectations are already set for the TasksRepository.GetTask method")
	}

	mmGetTask.mock.funcGetTask = f
	mmGetTask.mock.funcGetTaskOrigin = minimock.CallerInfo(1)
	return mmGetTask.mock
}

// When sets expectation for the TasksRepository.GetTask which will trigger the result defined by the following
// Then helper
func (mmGetTask *mTasksRepositoryMockGetTask) When(ctx context.Context, id string) *TasksRepositoryMockGetTaskExpectation {
	if mmGetTask.mock.funcGetTask != nil {
		mmGetTask.mock.t.Fatalf("TasksRepositoryMock.GetTask mock is already set by Set")
	}

	expectation := &TasksRepositoryMockGetTaskExpectation{
		mock:               mmGetTask.mock,
		params:             &TasksRepositoryMockGetTaskParams{ctx, id},
		expectationOrigins: TasksRepositoryMockGetTaskExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTask.expectations = append(mmGetTask.expectations, expectation)
	return expectation
}

// Then sets up TasksRepository.GetTask return parameters for the expectation previously defined by the When method
func (e *TasksRepositoryMockGetTaskExpectation) Then(tp1 *model.Task, err error) *TasksRepositoryMock {
	e.results = &TasksRepositoryMockGetTaskResults{tp1, err}
	return e.mock
}

// Times sets number of times TasksRepository.GetTask should be invoked
func (mmGetTask *mTasksRepositoryMockGetTask) Times(n uint64) *mTasksRepositoryMockGetTask {
	if n == 0 {
		mmGetTask.mock.t.Fatalf("Times of TasksRepositoryMock.GetTask mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTask.expectedInvocations, n)
	mmGetTask.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTask
}

func (mmGetTask *mTasksRepositoryMockGetTask) invocationsDone() bool {
	if len(mmGetTask.expectations) == 0 && mmGetTask.defaultExpectation == nil && mmGetTask.mock.funcGetTask == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTask.mock.afterGetTaskCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTask.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTask implements mm_service.TasksRepository
func (mmGetTask *TasksRepositoryMock) GetTask(ctx context.Context, id string) (tp1 *model.Task, err error) {
	mm_atomic.AddUint64(&mmGetTask.beforeGetTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTask.afterGetTaskCounter, 1)

	mmGetTask.t.Helper()

	if mmGetTask.inspectFuncGetTask != nil {
		mmGetTask.inspectFuncGetTask(ctx, id)
	}

	mm_params := TasksRepositoryMockGetTaskParams{ctx, id}

	// Record call args
	mmGetTask.GetTaskMock.mutex.Lock()
	mmGetTask.GetTaskMock.callArgs = append(mmGetTask.GetTaskMock.callArgs, &mm_params)
	mmGetTask.GetTaskMock.mutex.Unlock()

	for _, e := range mmGetTask.GetTaskMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmGetTask.GetTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTask.GetTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTask.GetTaskMock.defaultExpectation.params
		mm_want_ptrs := mmGetTask.GetTaskMock.defaultExpectation.paramPtrs

		mm_got := TasksRepositoryMockGetTaskParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTask.t.Errorf("TasksRepositoryMock.GetTask got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTask.GetTaskMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetTask.t.Errorf("TasksRepositoryMock.GetTask got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTask.GetTaskMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTask.t.Errorf("TasksRepositoryMock.GetTask got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTask.GetTaskMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTask.GetTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTask.t.Fatal("No results are set for the TasksRepositoryMock.GetTask")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmGetTask.funcGetTask != nil {
		return mmGetTask.funcGetTask(ctx, id)
	}
	mmGetTask.t.Fatalf("Unexpected call to TasksRepositoryMock.GetTask. %v %v", ctx, id)
	return
}

// GetTaskAfterCounter returns a count of finished TasksRepositoryMock.GetTask invocations
func (mmGetTask *TasksRepositoryMock) GetTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTask.afterGetTaskCounter)
}

// GetTaskBeforeCounter returns a count of TasksRepositoryMock.GetTask invocations
func (mmGetTask *TasksRepositoryMock) GetTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTask.beforeGetTaskCounter)
}

// Calls returns a list of arguments used in each call to TasksRepositoryMock.GetTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTask *mTasksRepositoryMockGetTask) Calls() []*TasksRepositoryMockGetTaskParams {
	mmGetTask.mutex.RLock()

	argCopy := make([]*TasksRepositoryMockGetTaskParams, len(mmGetTask.callArgs))
	copy(argCopy, mmGetTask.callArgs)

	mmGetTask.mutex.RUnlock()

	return argCopy
}

// MinimockGetTaskDone returns true if the count of the GetTask invocations corresponds
// the number of defined expectations
func (m *TasksRepositoryMock) MinimockGetTaskDone() bool {
	if m.GetTaskMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTaskMock.invocationsDone()
}

// MinimockGetTaskInspect logs each unmet expectation
func (m *TasksRepositoryMock) MinimockGetTaskInspect() {
	for _, e := range m.GetTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TasksRepositoryMock.GetTask at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTaskCounter := mm_atomic.LoadUint64(&m.afterGetTaskCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTaskMock.defaultExpectation != nil && afterGetTaskCounter < 1 {
		if m.GetTaskMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TasksRepositoryMock.GetTask at\n%s", m.GetTaskMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TasksRepositoryMock.GetTask at\n%s with params: %#v", m.GetTaskMock.defaultExpectation.expectationOrigins.origin, *m.GetTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTask != nil && afterGetTaskCounter < 1 {
		m.t.Errorf("Expected call to TasksRepositoryMock.GetTask at\n%s", m.funcGetTaskOrigin)
	}

	if !m.GetTaskMock.invocationsDone() && afterGetTaskCounter > 0 {
		m.t.Errorf("Expected %d calls to TasksRepositoryMock.GetTask at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTaskMock.expectedInvocations), m.GetTaskMock.expectedInvocationsOrigin, afterGetTaskCounter)
	}
}

type mTasksRepositoryMockUpdateTask struct {
	optional           bool
	mock               *TasksRepositoryMock
	defaultExpectation *TasksRepositoryMockUpdateTaskExpectation
	expectations       []*TasksRepositoryMockUpdateTaskExpectation

	callArgs []*TasksRepositoryMockUpdateTaskParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TasksRepositoryMockUpdateTaskExpectation specifies expectation struct of the TasksRepository.UpdateTask
type TasksRepositoryMockUpdateTaskExpectation struct {
	mock               *TasksRepositoryMock
	params             *TasksRepositoryMockUpdateTaskParams
	paramPtrs          *TasksRepositoryMockUpdateTaskParamPtrs
	expectationOrigins TasksRepositoryMockUpdateTaskExpectationOrigins
	results            *TasksRepositoryMockUpdateTaskResults
	returnOrigin       string
	Counter            uint64
}

// TasksRepositoryMockUpdateTaskParams contains parameters of the TasksRepository.UpdateTask
type TasksRepositoryMockUpdateTaskParams struct {
	ctx    context.Context
	id     string
	status model.Status
}

// TasksRepositoryMockUpdateTaskParamPtrs contains pointers to parameters of the TasksRepository.UpdateTask
type TasksRepositoryMockUpdateTaskParamPtrs struct {
	ctx    *context.Context
	id     *string
	status *model.Status
}

// TasksRepositoryMockUpdateTaskResults contains results of the TasksRepository.UpdateTask
type TasksRepositoryMockUpdateTaskResults struct {
	err error
}

// TasksRepositoryMockUpdateTaskOrigins contains origins of expectations of the TasksRepository.UpdateTask
type TasksRepositoryMockUpdateTaskExpectationOrigins struct {
	origin       string
	originCtx    string
	originId     string
	originStatus string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateTask *mTasksRepositoryMockUpdateTask) Optional() *mTasksRepositoryMockUpdateTask {
	mmUpdateTask.optional = true
	return mmUpdateTask
}

// Expect sets up expected params for TasksRepository.UpdateTask
func (mmUpdateTask *mTasksRepositoryMockUpdateTask) Expect(ctx context.Context, id string, status model.Status) *mTasksRepositoryMockUpdateTask {
	if mmUpdateTask.mock.funcUpdateTask != nil {
		mmUpdateTask.mock.t.Fatalf("TasksRepositoryMock.UpdateTask mock is already set by Set")
	}

	if mmUpdateTask.defaultExpectation == nil {
		mmUpdateTask.defaultExpectation = &TasksRepositoryMockUpdateTaskExpectation{}
	}

	if mmUpdateTask.defaultExpectation.paramPtrs != nil {
		mmUpdateTask.mock.t.Fatalf("TasksRepositoryMock.UpdateTask mock is already set by ExpectParams functions")
	}

	mmUpdateTask.defaultExpectation.params = &TasksRepositoryMockUpdateTaskParams{ctx, id, status}
	mmUpdateTask.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateTask.expectations {
		if minimock.Equal(e.params, mmUpdateTask.defaultExpectation.params) {
			mmUpdateTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateTask.defaultExpectation.params)
		}
	}

	return mmUpdateTask
}

// ExpectCtxParam1 sets up expected param ctx for TasksRepository.UpdateTask
func (mmUpdateTask *mTasksRepositoryMockUpdateTask) ExpectCtxParam1(ctx context.Context) *mTasksRepositoryMockUpdateTask {
	if mmUpdateTask.mock.funcUpdateTask != nil {
		mmUpdateTask.mock.t.Fatalf("TasksRepositoryMock.UpdateTask mock is already set by Set")
	}

	if mmUpdateTask.defaultExpectation == nil {
		mmUpdateTask.defaultExpectation = &TasksRepositoryMockUpdateTaskExpectation{}
	}

	if mmUpdateTask.defaultExpectation.params != nil {
		mmUpdateTask.mock.t.Fatalf("TasksRepositoryMock.UpdateTask mock is already set by Expect")
	}

	if mmUpdateTask.defaultExpectation.paramPtrs == nil {
		mmUpdateTask.defaultExpectation.paramPtrs = &TasksRepositoryMockUpdateTaskParamPtrs{}
	}
	mmUpdateTask.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateTask.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateTask
}

// ExpectIdParam2 sets up expected param id for TasksRepository.UpdateTask
func (mmUpdateTask *mTasksRepositoryMockUpdateTask) ExpectIdParam2(id string) *mTasksRepositoryMockUpdateTask {
	if mmUpdateTask.mock.funcUpdateTask != nil {
		mmUpdateTask.mock.t.Fatalf("TasksRepositoryMock.UpdateTask mock is already set by Set")
	}

	if mmUpdateTask.defaultExpectation == nil {
		mmUpdateTask.defaultExpectation = &TasksRepositoryMockUpdateTaskExpectation{}
	}

	if mmUpdateTask.defaultExpectation.params != nil {
		mmUpdateTask.mock.t.Fatalf("TasksRepositoryMock.UpdateTask mock is already set by Expect")
	}

	if mmUpdateTask.defaultExpectation.paramPtrs == nil {
		mmUpdateTask.defaultExpectation.paramPtrs = &TasksRepositoryMockUpdateTaskParamPtrs{}
	}
	mmUpdateTask.defaultExpectation.paramPtrs.id = &id
	mmUpdateTask.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateTask
}

// ExpectStatusParam3 sets up expected param status for TasksRepository.UpdateTask
func (mmUpdateTask *mTasksRepositoryMockUpdateTask) ExpectStatusParam3(status model.Status) *mTasksRepositoryMockUpdateTask {
	if mmUpdateTask.mock.funcUpdateTask != nil {
		mmUpdateTask.mock.t.Fatalf("TasksRepositoryMock.UpdateTask mock is already set by Set")
	}

	if mmUpdateTask.defaultExpectation == nil {
		mmUpdateTask.defaultExpectation = &TasksRepositoryMockUpdateTaskExpectation{}
	}

	if mmUpdateTask.defaultExpectation.params != nil {
		mmUpdateTask.mock.t.Fatalf("TasksRepositoryMock.UpdateTask mock is already set by Expect")
	}

	if mmUpdateTask.defaultExpectation.paramPtrs == nil {
		mmUpdateTask.defaultExpectation.paramPtrs = &TasksRepositoryMockUpdateTaskParamPtrs{}
	}
	mmUpdateTask.defaultExpectation.paramPtrs.status = &status
	mmUpdateTask.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmUpdateTask
}

// Inspect accepts an inspector function that has same arguments as the TasksRepository.UpdateTask
func (mmUpdateTask *mTasksRepositoryMockUpdateTask) Inspect(f func(ctx context.Context, id string, status model.Status)) *mTasksRepositoryMockUpdateTask {
	if mmUpdateTask.mock.inspectFuncUpdateTask != nil {
		mmUpdateTask.mock.t.Fatalf("Inspect function is already set for TasksRepositoryMock.UpdateTask")
	}

	mmUpdateTask.mock.inspectFuncUpdateTask = f

	return mmUpdateTask
}

// Return sets up results that will be returned by TasksRepository.UpdateTask
func (mmUpdateTask *mTasksRepositoryMockUpdateTask) Return(err error) *TasksRepositoryMock {
	if mmUpdateTask.mock.funcUpdateTask != nil {
		mmUpdateTask.mock.t.Fatalf("TasksRepositoryMock.UpdateTask mock is already set by Set")
	}

	if mmUpdateTask.defaultExpectation == nil {
		mmUpdateTask.defaultExpectation = &TasksRepositoryMockUpdateTaskExpectation{mock: mmUpdateTask.mock}
	}
	mmUpdateTask.defaultExpectation.results = &TasksRepositoryMockUpdateTaskResults{err}
	mmUpdateTask.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateTask.mock
}

// Set uses given function f to mock the TasksRepository.UpdateTask method
func (mmUpdateTask *mTasksRepositoryMockUpdateTask) Set(f func(ctx context.Context, id string, status model.Status) (err error)) *TasksRepositoryMock {
	if mmUpdateTask.defaultExpectation != nil {
		mmUpdateTask.mock.t.Fatalf("Default expectation is already set for the TasksRepository.UpdateTask method")
	}

	if len(mmUpdateTask.expectations) > 0 {
		mmUpdateTask.mock.t.Fatalf("Some expectations are already set for the TasksRepository.UpdateTask method")
	}

	mmUpdateTask.mock.funcUpdateTask = f
	mmUpdateTask.mock.funcUpdateTaskOrigin = minimock.CallerInfo(1)
	return mmUpdateTask.mock
}

// When sets expectation for the TasksRepository.UpdateTask which will trigger the result defined by the following
// Then helper
func (mmUpdateTask *mTasksRepositoryMockUpdateTask) When(ctx context.Context, id string, status model.Status) *TasksRepositoryMockUpdateTaskExpectation {
	if mmUpdateTask.mock.funcUpdateTask != nil {
		mmUpdateTask.mock.t.Fatalf("TasksRepositoryMock.UpdateTask mock is already set by Set")
	}

	expectation := &TasksRepositoryMockUpdateTaskExpectation{
		mock:               mmUpdateTask.mock,
		params:             &TasksRepositoryMockUpdateTaskParams{ctx, id, status},
		expectationOrigins: TasksRepositoryMockUpdateTaskExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateTask.expectations = append(mmUpdateTask.expectations, expectation)
	return expectation
}

// Then sets up TasksRepository.UpdateTask return parameters for the expectation previously defined by the When method
func (e *TasksRepositoryMockUpdateTaskExpectation) Then(err error) *TasksRepositoryMock {
	e.results = &TasksRepositoryMockUpdateTaskResults{err}
	return e.mock
}

// Times sets number of times TasksRepository.UpdateTask should be invoked
func (mmUpdateTask *mTasksRepositoryMockUpdateTask) Times(n uint64) *mTasksRepositoryMockUpdateTask {
	if n == 0 {
		mmUpdateTask.mock.t.Fatalf("Times of TasksRepositoryMock.UpdateTask mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateTask.expectedInvocations, n)
	mmUpdateTask.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateTask
}

func (mmUpdateTask *mTasksRepositoryMockUpdateTask) invocationsDone() bool {
	if len(mmUpdateTask.expectations) == 0 && mmUpdateTask.defaultExpectation == nil && mmUpdateTask.mock.funcUpdateTask == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateTask.mock.afterUpdateTaskCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateTask.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateTask implements mm_service.TasksRepository
func (mmUpdateTask *TasksRepositoryMock) UpdateTask(ctx context.Context, id string, status model.Status) (err error) {
	mm_atomic.AddUint64(&mmUpdateTask.beforeUpdateTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateTask.afterUpdateTaskCounter, 1)

	mmUpdateTask.t.Helper()

	if mmUpdateTask.inspectFuncUpdateTask != nil {
		mmUpdateTask.inspectFuncUpdateTask(ctx, id, status)
	}

	mm_params := TasksRepositoryMockUpdateTaskParams{ctx, id, status}

	// Record call args
	mmUpdateTask.UpdateTaskMock.mutex.Lock()
	mmUpdateTask.UpdateTaskMock.callArgs = append(mmUpdateTask.UpdateTaskMock.callArgs, &mm_params)
	mmUpdateTask.UpdateTaskMock.mutex.Unlock()

	for _, e := range mmUpdateTask.UpdateTaskMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateTask.UpdateTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateTask.UpdateTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateTask.UpdateTaskMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateTask.UpdateTaskMock.defaultExpectation.paramPtrs

		mm_got := TasksRepositoryMockUpdateTaskParams{ctx, id, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateTask.t.Errorf("TasksRepositoryMock.UpdateTask got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTask.UpdateTaskMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateTask.t.Errorf("TasksRepositoryMock.UpdateTask got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTask.UpdateTaskMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmUpdateTask.t.Errorf("TasksRepositoryMock.UpdateTask got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTask.UpdateTaskMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateTask.t.Errorf("TasksRepositoryMock.UpdateTask got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateTask.UpdateTaskMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateTask.UpdateTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateTask.t.Fatal("No results are set for the TasksRepositoryMock.UpdateTask")
		}
		return (*mm_results).err
	}
	if mmUpdateTask.funcUpdateTask != nil {
		return mmUpdateTask.funcUpdateTask(ctx, id, status)
	}
	mmUpdateTask.t.Fatalf("Unexpected call to TasksRepositoryMock.UpdateTask. %v %v %v", ctx, id, status)
	return
}

// UpdateTaskAfterCounter returns a count of finished TasksRepositoryMock.UpdateTask invocations
func (mmUpdateTask *TasksRepositoryMock) UpdateTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTask.afterUpdateTaskCounter)
}

// UpdateTaskBeforeCounter returns a count of TasksRepositoryMock.UpdateTask invocations
func (mmUpdateTask *TasksRepositoryMock) UpdateTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTask.beforeUpdateTaskCounter)
}

// Calls returns a list of arguments used in each call to TasksRepositoryMock.UpdateTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateTask *mTasksRepositoryMockUpdateTask) Calls() []*TasksRepositoryMockUpdateTaskParams {
	mmUpdateTask.mutex.RLock()

	argCopy := make([]*TasksRepositoryMockUpdateTaskParams, len(mmUpdateTask.callArgs))
	copy(argCopy, mmUpdateTask.callArgs)

	mmUpdateTask.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateTaskDone returns true if the count of the UpdateTask invocations corresponds
// the number of defined expectations
func (m *TasksRepositoryMock) MinimockUpdateTaskDone() bool {
	if m.UpdateTaskMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateTaskMock.invocationsDone()
}

// MinimockUpdateTaskInspect logs each unmet expectation
func (m *TasksRepositoryMock) MinimockUpdateTaskInspect() {
	for _, e := range m.UpdateTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TasksRepositoryMock.UpdateTask at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateTaskCounter := mm_atomic.LoadUint64(&m.afterUpdateTaskCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateTaskMock.defaultExpectation != nil && afterUpdateTaskCounter < 1 {
		if m.UpdateTaskMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TasksRepositoryMock.UpdateTask at\n%s", m.UpdateTaskMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TasksRepositoryMock.UpdateTask at\n%s with params: %#v", m.UpdateTaskMock.defaultExpectation.expectationOrigins.origin, *m.UpdateTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateTask != nil && afterUpdateTaskCounter < 1 {
		m.t.Errorf("Expected call to TasksRepositoryMock.UpdateTask at\n%s", m.funcUpdateTaskOrigin)
	}

	if !m.UpdateTaskMock.invocationsDone() && afterUpdateTaskCounter > 0 {
		m.t.Errorf("Expected %d calls to TasksRepositoryMock.UpdateTask at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateTaskMock.expectedInvocations), m.UpdateTaskMock.expectedInvocationsOrigin, afterUpdateTaskCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TasksRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateTaskInspect()

			m.MinimockDeleteTaskInspect()

			m.MinimockGetTaskInspect()

			m.MinimockUpdateTaskInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TasksRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TasksRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateTaskDone() &&
		m.MinimockDeleteTaskDone() &&
		m.MinimockGetTaskDone() &&
		m.MinimockUpdateTaskDone()
}
